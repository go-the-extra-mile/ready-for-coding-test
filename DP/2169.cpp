/*
# 문제 포인트
한 번 탐사한 지역은 탐사하지 않기로 하는 조건을 만족시키기 어려운 문제였다. 
전형적인 오른쪽, 아래쪽으로만 이동하는 문제는 자연스러운 순서로 문제를 풀면 알아서 조건이 만족된다. 
그러나 오른쪽, 아래쪽, 왼쪽으로 이동할 수 있을 때도 같은 방법을 적용하면 같은 지역을 두 번 이상 탐사하게 된다. 

## 예시
예를 들어 예제 입력 1의 맵이 주어지고 이에 대응되는 cache 배열이 있다고 하자. 
cache[i][j]: 로봇이 (1, 1)에서 출발해 (i, j)에 도착했을 때 최대가치

map
10  25  7   8   13
68  24  -78 63  32
12  -69 100 -29 -25
-16 -22 -57 -33 99
7   -76 -11 77  15

가장 윗 줄은 로봇이 오른쪽으로 이동해서만 도달할 수 있으므로
cache[0][j] = cache[0][j-1] + map[0][j]
로 구할 수 있다.

cache
10  35  42  50  63

두번째 줄부터 순서가 중요해진다. 
로봇이 오른쪽, 아래쪽으로만 이동할 수 있다고 가정하자. 
그러면 로봇이 칸 왼쪽에서 오는 경우, 위쪽에서 오는 경우의 최대가치를 비교해 더 큰 최대가치가 답이 된다. 
cache[1][0] = cache[0][0] + map[1][0]
(cache[1][j] = max(cache[0][j], cache[1][j-1]) + map[1][j]) for j = 1, 2, 3, 4
여기서 우리는 cache 배열을 왼쪽에서부터 채운다. 그 이유는 cache[1][0]는 로봇이 칸 왼쪽에서 오는 경우가 없으므로, 
결정된 답이기 때문이다. 

cache
10  35  42  50  63
78  102 24  58  95

이제 로봇이 왼쪽으로도 이동할 수 있는 문제상황을 고려하자. 
로봇이 오른쪽에서 오는 경우를 고려하려면 cache 배열을 오른쪽에서부터 채워야 한다. cache[1][4]는 로봇이 칸 오른쪽에서
오는 경우가 없으므로 이미 결정된 답이기 때문이다. 
여기서 같은 cache 배열을 이용할 수 없다는 것을 발견하게 된다. 지금의 cache 배열에는 왼쪽에서 온 경우도 포함되어 있으므로
한 지역의 가치를 중복으로 더하게 되기 때문이다. 
따라서 로봇이 왼쪽, 아래쪽으로 이동할 수 있는 경우의 최대가치를 비교해 더 큰 최대가치를 담는 두번째 cache가 필요하다. 
(cache[1][j] = max(cache[0][j], cache[1][j+1]) + map[1][j]) for j = 3, 2, 1, 0

cache2
10  35  42  50  63
172 104 80  158 95

이제 두 cache 배열의 두번째 줄에서 큰 값들만 고르면 로봇이 아래쪽, 왼쪽, 오른쪽으로 이동할 수 있을 때 최대가치가 된다. 

<풀이 개요>
1. 어떤 지역 (i, j)를 탐사하기 전에 (i-1, j)에 있었던 경우의 최대 가치를 구해 배열 A, B에 저장한다. 
2. 위쪽(i-1, j) 또는 왼쪽(i, j-1)에 있었던 경우의 최대 가치를 구해 배열 A에 저장한다. -> 위쪽이나 왼쪽에 있었던 경우의 최대 가치
3. 위쪽(i-1, j) 또는 오른쪽(i, j+1)에 있었던 경우의 최대 가치를 구해 배열 B에 저장한다. -> 위쪽이나 오른쪽에 있었던 경우의 최대 가치
4. 배열 A, B의 각 원소의 최대값을 구한다. -> 위쪽이나 왼쪽이나 오른쪽에 있었던 경우의 최대가치
*/
#include <iostream>
#include <algorithm>

using namespace std;

int map[1001][1001];
int dp[1001][1001];
int mx_from_top_left[1001][1001];
int mx_from_top_right[1001][1001];

int main() {
    cin.tie(0)->sync_with_stdio(0);

    int n, m; cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++){
            cin >> map[i][j];
        }
    }

    dp[1][1] = map[1][1];
    for (int j = 2; j <= m; j++) {
        dp[1][j] = dp[1][j-1] + map[1][j];
    }
    for (int i = 2; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            mx_from_top_left[i][j] = mx_from_top_right[i][j] = dp[i-1][j] + map[i][j];
        }

        for (int j = 2; j <= m; j++) {
            mx_from_top_left[i][j] = max(mx_from_top_left[i][j], mx_from_top_left[i][j-1] + map[i][j]);
        }
        for (int j = m-1; j >= 0; j--) {
            mx_from_top_right[i][j] = max(mx_from_top_right[i][j], mx_from_top_right[i][j+1] + map[i][j]);
        }
        
        for (int j = 1; j <= m; j++) {
            dp[i][j] = max(mx_from_top_left[i][j], mx_from_top_right[i][j]);
        }
    }
    
    cout << dp[n][m] << '\n';

    return 0;
}